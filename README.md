# Malware Detecting using Control Flow Graphs

[Link to Webpage](https://iamsabhoho.github.io/dsc180b-malware/)

## Introduction
There are many malware detection tools available in the market, including pattern-based, behavior-based methods, etc, with the prompt development of artificial intelligence, many modern data analysis methods are applied to detecting malware in recent years. We are interested in investigating the effectiveness of different data analysis methods for detecting certain types of malware.

As the number of malicious software (malware) increases throughout the past few decades, malware detection has become a challenge for app developers, companies hosting the apps, and people using the apps. There are many pieces of research conducted on malware detection since it first appeared in the early 1970s. Just like the paper we studied in our first quarter, it uses the HIN structure to classify the Android applications. It also compared its own method against other popular methods such as Naive Bayes and Decision Tree, and other known commercial mobile security products, to test its performance. The result showed that their method performs better than the other methods with an accuracy of 98\% while other others only achieve an average of 90\%. After studying the paper, we are more curious about the detecting effectiveness of an analysis method when applied to a certain type of malware.

![Project Pipeline]("/img/flow.png")

Not everyone has access to tools that can detect whether or not the app they just downloaded is malicious or not. Our motivation to conduct this research is to hope to produce a recommending tool that can be easily accessed by the general public for detecting malware. Optimistically, we want to reduce the chance of people downloading malicious apps and potentially prevent their devices from being hacked. To achieve that, we will be classifying applications using different similarity-based methods including k nearest neighbors (kNN) to see if different methods can detect certain types of malware or any specific features.

We are interested in analyzing whether one classifier has better performance in detecting certain types of malware or specific features, and designing a framework for recommending a method with a specific set of parameters for a certain type of malware and provide users a more friendly interface. With the similarity-based approach, we believe that it will detect malware with much higher accuracy and will be more flexible for applications that evolved over time as they become more complicated.

## Related Work

### Mamadroid
MamaDroid is a system that detects Android malware by the apps' behaviors. This method extract call graphs from APKs, which are represented using nodes and edges in a graph object. From each graph, sequences of probabilities are extracted, representing one feature vector per APK. These probabilistic feature vectors are used for malware classification. 

### Hindroid
Hindroid is a system that parses SMALI code extracted from APKs and uses them to create four different graphs, which are represented by large matrices. Within these matrices, each value in a matrix corresponds to an edge. A combination of these matrices are used to classify malicious software and benign apps.  

### Metapath2Vec
Metapath2Vec is a node representation learning model that uses predefined paths based on the node types. These paths define where the the program can traverse the graph. Following is an example of a metapath. In this case below, the metapath is Type 1 → Type 2 → Type 1 → Type 3 → Type 1.

![Metapath2vec Example]("/img/m2v.png") 

With these metapaths, we then generate a corpus using this method repeatedly to learns representations. This method will obtain one vector for one node within the graph.

### Word2Vec
Word2vec is a model that turns text into numerical representations. Having corpus as input data and outputting a vector as its representation. Below is a famous example of Word2Vec: King and Queen and Men and Women. 

![Word2vec Example]("/img/w2v.png") 

Since Word2Vec measures the similarity between words using Cosine similarity, we can see from the above vector space that the word King is similar to Queen, and Men is similar to Women. 

[In our project, how did we use them?]

### Doc2Vec
Similar to Word2Vec, Doc2Vec turns a whole document/paragraph into numerical representations instead of just one text.

[In our project, how did we use them?]


## Data
The data we will be using is randomly downloaded from APK Pure and AMD malware dataset. It consists of labeled malware and other popular and unpopular (random) applications. Among our random apps downloaded from APK Pure, there might be one app out of five that might be a malware since they are apps that have little or no reviews. Rather than using .SMALI files, we will be working with APK files directly. With APK files, we can easily generate control flow graphs through Androguard \cite{androguard}, which is a powerful tool to disassemble and decompile Android applications.

### Control Flow Graphs
A Control Flow Graph (CFG) is a representation using graph notation of all paths that might be traversed through a program during execution. Control Flow is the order in which individual statements, instructions, or function calls of an imperative program are executed or evaluated. Imperative meaning statements that change a program’s state. Each node in the CFG represents a basic block, or a straight-line piece of code without any jumps or jump targets. In our case, a node in the CFG is an API or method call. A jump statement is a statement that changes the program’s flow into another place of the source code. The following figure are two simple control flow graphs.

![A Simple Control Flow Graph]("/img/cfg.png")

A node in our CFG can call another API (node). There are 7 Boolean attributes for each node, and 3 different edge types. 

| Node Attributes | |
| --- | --- |
| External | If a node is an external method |
| Entrypoint | If a node is not called by anything |
| Native | If a node is native |
| Public | If the node is a public method |
| Static | If the node is a static method |
| Node | If none of the above are True |
| APK Node | If the node is an APK |


We can pick from the 6 Boolean attributes and create node types based, such as: “external, public Node”, “external, static Node” and “entrypoint, native Node”. There can be 20 different node types. 

| Edge Types | |
| --- | --- |
| Calls | API to API |
| Contains | APK to API |
| In | API to APK |


Together, nodes and edges can build paths like: “external, public Node - calls --$>$ external, static Node” or “APK - contains --$>$ external, public Node”. The following is a control flow graph example with code block to explain how nodes are called:

\begin{Verbatim}[commandchars=\\\{\}, tabsize=5]
Class: Lclass0/package0/exampleclass; ## let’s call this A
# direct methods
.method \textcolor{red}{public} constructor <init>()V
	# api, call this B:
	Lclass1/package1/example;->doSomething(Ljava/lang/String;)V
	# api, call this C:
	Lclass2/package2/example;->perform(L1/2/3)F
\end{Verbatim}

![Control Flow Graph With Code Block Example]("/img/cfg1.png")

The method constructor calls API A, which calls API B: doSomething and calls API C: perform.

[more explanation?]


### Common Graph
Since we obtained a large number of CFGs for a large number of APKs, we need to figure out a way to connect all of these graphs so the representations for each app will be similar. To achieve this, we must create a common graph that links every CFG together. By connecting all our CFGs, we are able to get embeddings for each node, including the APK nodes and the API nodes. With that, we extract only the APK nodes’ embeddings to further perform our similarity comparisons between our apps. Our common graph is built similar to the A matrix by creating APK nodes, API nodes, as well as APK to API and API to APK edges. We must also make sure that the same API nodes in two different CFGs are represented the same, or else our model will be training on random data.

![Common Graph Example]("img/common_graph2.png")

The figure above demonstrates what a common graph looks like by combining two control flow graphs from two different apps. On the left we have red and blue applications, which both have five nodes consists of A, B, and C nodes connected together and other nodes of its own. When combining them, we generate a graph on the right, which merge the shared nodes with each other, called the common graph. Our goal is to build a large common graph composed of all data we have. With the common graph, we can obtain embeddings for each APK and API nodes and perform similarity comparisons between them.

### DFG/ETL
The raw data that we are investigating is code written by app developers. In order to turn something into a malware, you have to alter the source code, which will allow hackers to plant certain types of malicious code. If a developer were to hijack a device, then the app would need special Root permissions. Often targeting API calls that represent System Calls is one of the ways to alter the source code. For that reason, source code is an essential part in determining whether an application is malicious or not. 

As mentioned above, this project we will be using control flow graphs converted directly from the APK files.We are looking at the sequence of which these system calls are made and define them as meta paths. We were able to obtain one CFG for each apk. We extracted this by using Androguard’s AnalysisAPK method in its misc module which returns an analysis object. Afterwards, we called .get\_call\_graph() on the analysis object to obtain the CFG. At this stage, we also perform some feature extraction specifically on the nodes of the graph. We extract the string representation of these nodes as well as node type. We then exported this graph as a compressed gml file to save on disk. To get our training and validation matrices, we combine the individual graphs by a disjoint union common graph. Afterwards, the processed data is fed through metapath2vec to get representations of apps. We hypothesize that by using control flow graphs, our model can better detect malware since it can better represent the connections between nodes and edges and also represent the order of code that are executed, which have stronger relationships than just analyzing API calls themselves.






### EDA
We have a total of 8435 malicious software and a total of 802 benign applications, which is a combination of popular apks and random apps. While generating control flow graph objects from the APK files, there was an error of “\textit{Missing AndroidManifest.xml},” so we were not able to generate those graphs and will be working with fewer benign apps \footnote{We looked into why there might be missing Android Manifest files error, interestingly, we found that some of the apps having this issue contain the manifest while some do not. However, the apps that have this issue do not decompile correctly, and do not create a graph correctly as well.}. To counteract the imbalance between malware and benign apps, we calculated class weights and used it in the classification process to ensure we are penalizing the model in a balanced way.

To further understand our benign and malicious data, we performed analysis on these graph objects by comparing the node and edge types, as well as the counts of both nodes and edges.

\begin{figure}[H]
\begin{subfigure}{\textwidth}
\centering
\includegraphics[width=\linewidth=]{bv_node_types.png} 
\end{subfigure}
\caption{Benign vs. Malicious: Node Type Counts}
\label{flow}
\end{figure} 

The figure shows the comparisons of node types between benign applications and malware. From the two distributions, we can see that malware contains more types of nodes compared to benign apps. 

[MORE EDA]

\begin{figure}[H]
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=\linewidth]{bv_node_num.png}
\caption{Benign vs. Malicious: Node Counts}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=\linewidth]{bv_edge_num.png}
\caption{Benign vs. Malicious: Edge Counts}
\end{subfigure}
\caption{Benign vs. Malicious: Node and Edge Counts}
\end{figure}

The two distributions above show that malicious app has more counts in both number of nodes and number of edges, which might be because they are more complicated than benign apps. 

[MORE EXPLANATIONS]


## Methods

### Feature Extraction
For our features, we will be extracting nodes and edges from our graph. Unlike the Hindroid paper, it is generating heterogeneous graphs from two apps, we are only extracting graphs from one app at a time. After graph extraction, we will vectorize it using metapath2vec from StellarGraph\cite{stellargraph}.

### Metapath2vec
- what is and how are we using metapath2vec

### Baseline: Mamadroid
We build Mamadroid as our baseline model. As introduced earlier, it extract call graphs that are represented using nodes and edges. With the graphs, it then extract sequences of probabilities, which represent one feature vector per APK. And this probabilistic feature vector is used for classification.

Built MamaDroid and used it as our baseline
Abstracted API calls to Family or Package level
Example: API call = “LFamily\Package”
Package level : “LFamily\Package”
Family Level: “LFamily\”
In Family level: 7 possible families, and 100 total possible edges
In Package mode: 226 possible packages, and 51239 total possible edges
Classified using Random Forest (100 trees), 1-Nearest Neighbors, 3-Nearest Neighbors. 

### Models
From control flow graphs extracted from our raw APKs, abstract to the class level
Example:  “LFamily\Package\class;”
To reduce computational size, be more specific than our baseline
Create a common graph
From common graph, traverse the graph using DFS to find all possible metapaths, ensuring every node is covered
Using metapaths from the previous step, run metapath2vec on the common graph
Classify using representations of APK nodes, and their corresponding labels using: 1-NN, 3-NN, SVM, and Random Forest. 



## Results and Analysis
### Baseline Results
Mamadroid results:

| PCA = 10 Components | Random Forest | 1-NN | 3-NN |
| --- | --- | --- | --- |
| Family F1 score | 0.994 | 0.989 | 0.98 |
| Family Confusion Matrix | TN = 68 FN = 4 FP = 11 TP = 1269 | TN = 61 FN = 9 FP = 18 TP = 1264 | TN = 59  FN = 8 FP = 20 TP = 1265 |
| Package F1 Score | 0.993 | 0.9917 | 0.9937 |
| Package Confusion Matrix | TN = 70 FN = 1 FP = 15 TP = 1266 | TN = 70  FN = 6 FP = 15 TP = 1261 | TN = 70 FN = 1 FP = 15 TP = 1266 |



## Conclusion
- conclusion goes here


## References
- some references

