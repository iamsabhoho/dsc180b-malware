from androguard import misc
from androguard import session
from stellargraph import StellarGraph
import networkx as nx
from androguard.core.analysis import auto
from datetime import datetime

import os


# concurrency
from concurrent.futures import ThreadPoolExecutor

import utils


# txt file for apps
def train_txt(malware, benign1, benign2):
    """
    benign_fp --> file path for directory of benign_apps
    mali_fp --> file path for directory of malicious apps

    Assigns an ID to each app

    output --> train.txt containing train apps, columns = app_ID, app_fp, label
    """

    benign_apps = [(benign1 + bee) for bee in os.listdir(benign1)] + \
    [(benign2 + bee) for bee in os.listdir(benign2)]
    benign_labels = [0] * len(benign_apps)
    print(len(benign_apps))

    # note, malware are already CFGs
    malware_apps = [(malware + bee) for bee in os.listdir(malware)]
    malware_labels = [1] * len(malware_apps)
    print(len(malware_apps))

    apps = benign_apps + malware_apps
    labels = benign_labels + malware_labels

    # app ID's
    app_id = range(0, (len(benign_apps) + len(malware_apps)))

    csv = pd.DataFrame({
        "app_fp":apps,
        "app_label":labels,
        "app_ID":app_id
    })

    csv.to_csv("features/app_label_id.txt", index=  False)
    return csv


##################### ETL (EXTRACTING, TRANSFORMING, LOADING DATA) ######



def etl(directories, target):
    """
    perform ETL on directories, outputs to targets
    
    ETL process:
    1. apk --> decompile to a, d, dx
    2. a, d, dx --> dx.get_call_graph() (networkx object)
    3. perform feature extraction on (networkx object)
    4. export networkx object as a compressed .gml file

    directory --> directories containing the apps we want to get graphs from
    target --> outputs folder .gml.bz2 files to a target destination
    """
    
    for directory in directories:
        filepaths = os.listdir(directory)
        for filepath in filepaths:
            real_p = os.path.join(directory, filepath)
            
            now = datetime.now()
            decompile_apk(real_p, target)
            print("for app: filepath, took: ", (datetime.now() - now), "\n\n")
            
            
        





def decompile_apk(filepath, target_dir):
    '''
    decompiles an apk and outputs a gml file of the graph. Will write to disk.

    filepath --> path to the APK file
    session_n --> session filename, extension is '.ag'


    '''
    # build fp
    path, app = os.path.split(filepath)
    app = app.replace(".apk", "")

    final_path = os.path.join(target_dir, (app + ".gml.bz2"))


    a, d, dx = misc.AnalyzeAPK(filepath)
    networkx_graph = dx.get_call_graph()

    mapping = {}
    for node_id, node_data in networkx_graph.nodes(data = True):
        mapping[node_id] = str(node_id.get_method().full_name)
        node_data['feature'] = features_encoder(node_data)
        node_data['type'] = features_encoder2(node_data)

    G = nx.relabel_nodes(networkx_graph, mapping)
    nx.write_gml(G, final_path)

    return "Done"

def features_encoder(node_data):
    """
    encoding the feature dictionary from .get_call_graph() from Androguard
    """
    keywords= ["external", 'entrypoint', 'native', 'public', 'static'] #'vm', 'codesize']
    vector = []
    for keyword in keywords:
        try:
            if node_data[keyword] == True:
                vector.append(1)
            else:
                vector.append(0)
        except:
            vector.append(0)

    return vector

def features_encoder2(node_data):
    '''
    gets the node type for an individual node

    returns a string
    '''
    keywords = ["external", 'entrypoint', 'native', 'public', 'static']

    string = ""
    for keyword in keywords:
        if node_data[keyword] == True:
            string += (keyword + ",")

    string = string[:-1]
    string += "Node"
    return string

def call_graph(dx):
    """
    1. gets the call graph (CFG) from the analysis object (dx)
    2. processes the nodes by giving them a node_type for easier representation
    3. also gives edges representation

    returns a stellargraph.core.graph.StellarDiGraph object


    dx --> analysis object from decompiling an apk
    """

    call_graph_nx = dx.get_call_graph()
    for node_id, node_data in call_graph_nx.nodes(data = True):
        node_data['feature'] = features_encoder(node_data)
        node_data['type'] = features_encoder2(node_data)


    call_graph_sg = graph = StellarGraph.from_networkx(test_dx, node_features = \
    "feature", node_type_attr = 'type', edge_type_attr = 'offset')

    return call_graph_sg



if __name__ == "__main__":
    
    # ur username: change here
    USER = "ssh026"
    
    
    # target 
    #target = utils.get_to_directory(USER, ["DSC180A_FA20_A00", "a04malware", "personal-group03", "benign_graphs_sab", "popular_apks"])
    target = "/teams/DSC180A_FA20_A00/a04malware/personal-group03/benign_graphs_sab/popular_apks"

    # malwares (they're already graph format)
    malware_directory = utils.get_to_directory(USER, ["DSC180A_FA20_A00", "a04malware", "apks", "malware"])

    # benigns
    #benign1_directory = utils.get_to_directory(USER, ["DSC180A_FA20_A00", "a04malware", "apks", "popular_apks"])
    benign2_directory = utils.get_to_directory(USER, ["DSC180A_FA20_A00", "a04malware", "apks", "random-apps"])

    benign1_directory = "/teams/DSC180A_FA20_A00/a04malware/apks/popular_apks"

    executor = ThreadPoolExecutor(8)
    future = executor.submit(etl, [benign1_directory], target)
    information = future.result()
