# importing required packages
import numpy as np
import os
import re
from concurrent.futures import ThreadPoolExecutor
import matplotlib.pyplot as plt


# importing modules from relative folders
import sys,inspect
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0,parentdir)
from data import *

# Regarding EDA:
# It is very important to understand the data you are working with.
# Even though you have read HinDroid, don’t let that hinder your intuition
# of what could be a very good feature.
# You don’t necessarily have to limit yourself to the A, B, P etc.
# Ask the following questions and then try to figure out if you can answer them
# using the decompiled APK:

# What are the most common API calls overall/individually for an App?
# If you know what an App does (say a document viewer), does this explain the
#API calls present/absent in this App.

# How many base java methods occur in each application?
# Can you find out some API calls that are domain-specific?
# Average number of methods per App/average number of API calls per method?
# Size of the app

def get_unique(fp):
    '''
    fp --> a filepath of a directory that contains the apps
    get unique api's and codeblocks of smalis


    returns
    '''
    raw = []
    apis = []
    codeblocks = []


    for subdir, dirs, files in os.walk(fp):
        for filename in files:
            fp = subdir + os.sep + filename
            if fp.endswith(".smali") or fp.endswith(".smali"):
                with open(fp, encoding = "utf-8") as file:
                    f = file.read()
                    raw = raw + re.findall(r"invoke-.+\s?L.*;", f)
                    codeblocks = codeblocks + re.split("\.method", f)
                file.close()

    return [np.array(raw, dtype = object),
    np.array(codeblocks, dtype = object)]

def eda_cooccurence(apis):
    """
    apis --> array of apis
    gets the co-occurences for API's

    returns a tuple of unique apis and their counts
    """

    return np.unique(apis, return_counts = True)


def eda_invoke(apis):
    """
    apis --> np array of raw API calls
    output counts of different invoke methods

    """

    joined = "".join(apis)

    invoke_methods = np.array([
    "invoke-static", "invoke-virtual", "invoke-direct", "invoke-super",
    "invoke-interface"], dtype = object)

    cts = []

    for method in invoke_methods:
        cts.append(len(re.findall(method, joined)))

    return np.array([invoke_methods, np.array(cts, dtype = object)])


def eda_package(apis):
    """
    apis --> array of raw API calls
    """




def get_counts(fp):

    '''
    gets the counts for raw api's, processed api's, and codeblocks for a certain folder
    fp --> directory that contains apps

    '''
    app_list = os.listdir(fp)

    raws = []
    apis = []
    codeblocks = []

    for file in app_list:
        print("fp: ", (fp + "/" + file))
        executor = ThreadPoolExecutor(4)
        future = executor.submit(get_info, (fp + "/" + file))
        a, b, c = future.result()
        raws.append(len(a))
        apis.append(len(b))
        codeblocks.append(len(c))
    return [app_list, raws, apis, codeblocks]



def create_figures(labels, raws, apis, codeblocks):
    '''
    creating some figures and saves them into "/figures" describing stats for the apps in a directory
    '''


    width = 0.2
    fig, ax = plt.subplots()
    x = np.arange(len(labels))
    width = 0.35  # the width of the bars
    fig, ax = plt.subplots()
    rects1 = ax.bar(x - width/2, raws, width, label='apis')
    rects2 = ax.bar(x + width/2, codeblocks, width, label='codeblocks')
    # Add some text for labels, title and custom x-axis tick labels, etc.
    ax.set_ylabel('Counts')
    ax.set_title('Counts of apis and codeblocks on sample apps')
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    ax.legend()

    fig.tight_layout()
    plt.savefig("out.png")
    plt.show()
