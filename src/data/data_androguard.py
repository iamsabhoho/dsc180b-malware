from androguard import misc
from androguard import session
from stellargraph import StellarGraph
import networkx as nx
from androguard.core.analysis import auto
from datetime import datetime
import sys
import os
import pandas as pd
import numpy as np

# metapath2vec stuff
from stellargraph.data import UniformRandomMetaPathWalk
from gensim.models import Word2Vec



# concurrency
import concurrent.futures

## getting utils
import sys,inspect
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0,parentdir)
import utils




# txt file for apps
def train_txt(malware, benign1, benign2, target):
    """
    benign_fp --> file path for directory of benign_apps
    mali_fp --> file path for directory of malicious apps

    Assigns an ID to each app

    output --> train.txt containing train apps, columns = app_ID, app_fp, label
    """

    benign_apps = [os.path.join(benign1, bee) for bee in os.listdir(benign1)] + \
    [os.path.join(benign2, bee) for bee in os.listdir(benign2)]
    benign_labels = [0] * len(benign_apps)
    print(len(benign_apps))

    # note, malware are already CFGs
    malware_apps = [os.path.join(malware, bee) for bee in os.listdir(malware)]
    malware_labels = [1] * len(malware_apps)
    print(len(malware_apps))

    apps = benign_apps + malware_apps
    labels = benign_labels + malware_labels

    # app ID's
    app_id = range(0, (len(benign_apps) + len(malware_apps)))

    csv = pd.DataFrame({
        "app_fp":apps,
        "app_label":labels,
        "app_ID":app_id
    })
    
    # build outputfp: 
    outfp = os.path.join(target, "app_label_id.txt")
    if os.path.exists(outfp) & (".txt" in outfp):
        os.remove(outfp)
    csv.to_csv(outfp, index = False)
    return csv


##################### ETL (EXTRACTING, TRANSFORMING, LOADING DATA) ####################



#     futures = []
#     with ThreadPoolExecutor(8) as executor:

#         for directory in directories:
#             filepaths = os.listdir(directory)
#             for filepath in filepaths:
#                 real_p = os.path.join(directory, filepath)
#                 now = datetime.now()
#                 futures.append(executor.submit(decompile_apk, real_p, target))
#         for job in as_completed(futures):
#             results = job.result()

def read_graph_process(fp):
    '''
    reads and decompresses .gml.bz2 file to obtain the graph
    
    fp --> filepath to .gml.bz2 file (should be the graph)
    '''
    # get app name
    direc, app = os.path.split(fp)
    app = app.replace(".gml.bz2", "")
    
    graph = nx.read_gml(fp)
#     graph.add_nodes_from([
#         app, {""}
#     ])
    
#     stellar = StellarGraph.from_networkx(graph, node_type_attr= 'type')
    return graph

def etl(directories, target):
    """
    perform ETL on directories, outputs to targets

    ETL process:
    1. apk --> decompile to a, d, dx
    2. a, d, dx --> dx.get_call_graph() (networkx object)
    3. perform feature extraction on (networkx object)
    4. export networkx object as a compressed .gml file

    directory --> directories containing the apps we want to get graphs from
    target --> outputs folder .gml.bz2 files to a target destination
    """

#     for directory in directories:
#         filepaths = os.listdir(directory)
#         for filepath in filepaths:
#             real_p = os.path.join(directory, filepath)
#             decompile_apk(real_p, target)

    for directory in directories:
        
        settings = {
            "my" : AndroTest(directory),
            "log":auto.DefaultAndroLog,
            "max_fetcher":3
        }

        aa = auto.AndroAuto(settings)
        aa.go()

def decompile_apk(filepath):
    '''
    decompiles an apk and outputs a gml file of the graph. Will write to disk.

    filepath --> path to the APK file
    session_n --> session filename, extension is '.ag'


    '''
    # build fp
    path, app = os.path.split(filepath)
    app = app.replace(".apk", "")
    
    target = utils.get_to_directory("edh021", ["DSC180A_FA20_A00", "a04malware", "personal-group03", "benign_graphs"])
    final_path = os.path.join(target, (app + ".gml.bz2"))


    a, d, dx = misc.AnalyzeAPK(filepath)
    networkx_graph = dx.get_call_graph()

    mapping = {}
    for node_id, node_data in networkx_graph.nodes(data = True):
        mapping[node_id] = str(node_id.get_method().full_name)
        node_data['feature'] = features_encoder(node_data)
        node_data['type'] = features_encoder2(node_data)

    G = nx.relabel_nodes(networkx_graph, mapping)
    nx.write_gml(G, final_path)

    return final_path

def features_encoder(node_data):
    """
    encoding the feature dictionary from .get_call_graph() from Androguard
    """
    keywords= ["external", 'entrypoint', 'native', 'public', 'static'] #'vm', 'codesize']
    vector = []
    for keyword in keywords:
        try:
            if node_data[keyword] == True:
                vector.append(1)
            else:
                vector.append(0)
        except:
            vector.append(0)

    return vector

def features_encoder2(node_data):
    '''
    gets the node type for an individual node

    returns a string
    '''
    keywords = ["external", 'entrypoint', 'native', 'public', 'static']

    string = ""
    for keyword in keywords:
        if node_data[keyword] == True:
            string += (keyword + ",")

    string = string[:-1]
    string += "Node"
    return string

def call_graph(dx):
    """
    1. gets the call graph (CFG) from the analysis object (dx)
    2. processes the nodes by giving them a node_type for easier representation
    3. also gives edges representation

    returns a stellargraph.core.graph.StellarDiGraph object


    dx --> analysis object from decompiling an apk
    """

    call_graph_nx = dx.get_call_graph()
    for node_id, node_data in call_graph_nx.nodes(data = True):
        node_data['feature'] = features_encoder(node_data)
        node_data['type'] = features_encoder2(node_data)


    call_graph_sg = graph = StellarGraph.from_networkx(test_dx, node_features = \
    "feature", node_type_attr = 'type', edge_type_attr = 'offset')

    return call_graph_sg


def metapath2vec(graph_fp, label):
    """
    performs metapath2vec and returns representations with labels
    """
    
    networkx = nx.read_gml(graph_fp)
    graph = StellarGraph.from_networkx(networkx, node_type_attr = "type")
    
    walk_length = 10
    metapaths = [
        ["public,Node", "external,Node", "public,Node"]
    ]

    rw = UniformRandomMetaPathWalk(graph)

    walks = rw.run(
        nodes=list(graph.nodes()),  # root nodes
        length=walk_length,  # maximum length of a random walk
        n=1,  # number of random walks per root node
        metapaths=metapaths,  # the metapaths
    )
    
    model = Word2Vec(walks, size=128, window=5, min_count=0, sg=1, workers=2, iter=1)
    return (model.wv.vectors, [label] * len(model.wv.vectors))




class AndroTest(auto.DirectoryAndroAnalysis):
    def __init__(self, path):
        super(AndroTest, self).__init__(path)
#         self.has_crashed = False

    def analysis_app(self, log, apkobj, dexobj, analysisobj):
#         Just print all objects to stdout
        networkx_graph = analysisobj.get_call_graph()

        mapping = {}
        for node_id, node_data in networkx_graph.nodes(data = True):
            mapping[node_id] = str(node_id.get_method().full_name)
            node_data['feature'] = features_encoder(node_data)
            node_data['type'] = features_encoder2(node_data)

        G = nx.relabel_nodes(networkx_graph, mapping)
        
        # MUST CHANGE TO YOUR USERNAME, AND ENSURE THE PATH EXISTS
        TARGET_DIR = utils.get_to_directory('edh021', ["DSC180A_FA20_A00", "a04malware", "personal-group03", "benign_graphs"])
        app = str(apkobj.get_filename())
        app = app.replace(".apk", "")
        app = app.replace("raw_apk_sha256:", "")
        final_path = os.path.join(TARGET_DIR, (app + ".gml.bz2"))
        
        print(final_path)
        nx.write_gml(G, final_path)


    def finish(self, log):
        # This method can be used to save information in `log`
        # finish is called regardless of a crash, so maybe store the
        # information somewhere
        if self.has_crashed:
            print("Analysis of {} has finished with Errors".format(log))
        else:
            print("Analysis of {} has finished!".format(log))




if __name__ == "__main__":

    # ur username: change here
    USER = "edh021"


    # target
    target = utils.get_to_directory(USER, ["DSC180A_FA20_A00", "a04malware", "personal-group03", "benign_graphs"])
    # malwares (they're already graph format)
    malware_directory = utils.get_to_directory(USER, ["DSC180A_FA20_A00", "a04malware", "apks", "malware"])
    # benigns
    benign1_directory = utils.get_to_directory(USER, ["DSC180A_FA20_A00", "a04malware", "apks", "popular_apks"])
    benign2_directory = utils.get_to_directory(USER, ["DSC180A_FA20_A00", "a04malware", "apks", "random-apps"])

    print("does file paths exist? Target:", os.path.exists(target), " malware: ", os.path.exists(malware_directory), " benign1: ", os.path.exists(benign1_directory), " benign2: ", os.path.exists(benign2_directory))


    now = datetime.now()

    settings = {
        "my" : AndroTest("/Users/edwinhuang/Documents/GitHub/dsc180b-localtesting/data/apks"),
        "log":auto.DefaultAndroLog,
        "max_fetcher":4
    }

    aa = auto.AndroAuto(settings)
    aa.go()

    print("5 same apps took: ", (datetime.now() - now))
