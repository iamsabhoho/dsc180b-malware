import numpy as np
import regex as re
import networkx as nx
from stellargraph import StellarGraph
# import concurrent.futures
import multiprocessing
import glob




import pandas as pd
import numpy as np

import os


# getting to utils
import sys,inspect
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0,parentdir)
import utils

POSSIBLE_FAMILIES = "Landroid,Lgoogle,Ljava,Ljavax,Lxml,Lapache,Ljunit,Ljson,Ldom".split(",")
POSSIBLE_PACKAGES = "/teams/DSC180A_FA20_A00/a04malware/personal-group03/mamadrioid_intermediate_files/all_possible_packages.txt"
POSSIBLE_EDGES = "/teams/DSC180A_FA20_A00/a04malware/personal-group03/mamadrioid_intermediate_files/all_possible_edges.txt"



def get_possible_packages():
    """
    obtains the list of possible packages for the latest API level, FOR PACKAGE MODE
    returns a list of possible packages. 
    """
    
    possible_packages = []
    with open(POSSIBLE_PACKAGES, 'r') as file:
        for line in file:
            line = "L" + line
            possible_packages.append(line.rsplit("."))
    file.close()
    return possible_packages
    

def get_possible_edges():
    """
    obtains the list of all possible edges according to the packages we have, for PACKAGE MODE
    """
    
    possible_edges = []
    with open(POSSIBLE_EDGES, 'r') as file:
        for line in file:
            sep = line.split()
            edge = (sep[0], sep[1])
            possible_edges.append(edge)
    file.close()
    return possible_edges

def get_possible_family_edges():
    """
    obtains the list of all possible edges created using FAMILY MODE
    """
    possible_edges = []
    for family1 in POSSIBLE_FAMILIES:
        for family2 in POSSIBLE_FAMILIES:
            possible_edges.append((family1, family2))
            
    return possible_edges

def get_package_family(kind, api):
    """
    gets a package or family from api
    
    kind --> string, FAMILY or PACKAGE
    api --> string of the api
    """
    package_fp = os.path.join(POSSIBLE_PACKAGES)
    possible_packages = []
    with open(package_fp, 'r') as file:
        for line in file:
            line = "L" + line
            possible_packages.append(line.split("."))
    file.close()

    if kind == "FAMILY":
        sep = api.split("/")[:1][0]
        if sep in POSSIBLE_FAMILIES:
            return sep
        else:
            return "self_defined"
       
    elif kind == "PACKAGE":
        
        for package in possible_packages:
            ct = 0
            for item in package:
                processed = item.replace("\n", "")
                if processed in api:
                    ct += 1
                else:
                    continue
            if (ct == len(package)) & (ct > 1):
                to_return = "/".join(package).replace("\n", "")
                return to_return
        if package == possible_packages[-1]:
            return "self_defined"


def edge_processing(edge, kind):
    """
    performs get_package_family on an edge
    edge --> a list that is an edge
    """
    new_edge = []
    for edg in edge:
        if type(edg) != int:
            new_edge.append(get_package_family(kind, edg))
        else:
            new_edge.append(edg)
    return new_edge


def get_markov(inFP, outFP, kind):
    
    """
    obtains the markov chain for one app
    
    inFP --> input file path (should be .gml.bz2)
    outFP --> output directory
    kind --> (str) FAMILY or PACKAGE
    
    """
    direc, app_name = utils.dir_and_app(inFP)
    outputfp = os.path.join(outFP, (app_name + "_" + kind + ".txt"))

    # check if the output fp exists
    if os.path.exists(outputfp):
        return
    else:
        try:
            networkx = nx.read_gml(inFP)
        except:
            return inFP + " might be broken!"
        
        nx_nodes = np.array(networkx.nodes())
        nx_edges = np.array(networkx.edges, dtype = object)
        
        # convert to package/family mode 
        vfunc = np.vectorize(get_package_family)
        newnodes = vfunc(kind, nx_nodes)
        new_edges = []
        for edge in nx_edges:
            new_edges.append(edge_processing(edge, kind))
        G = nx.MultiDiGraph()
        G.add_nodes_from(newnodes)
        G.add_edges_from(new_edges)
        stellar = StellarGraph.from_networkx(G)

        # step2: markov chain
        ## Set of possible states of the Markov chain is denoted as S
        ## If Sj and Sk are two connected states, Pjk denotes P(transition from Sj to Sk)
        ## Pjk is # occurances(Ojk), or edges(from j to k), divided by # of all occurrences
        ## Pjk = # of Edge(j, k) / # total edges
        if kind == "PACKAGE":
            possible_packages = get_possible_packages()
            S = ["/".join(item).strip() for item in possible_packages] + ["self_defined"]
            possible_edges = get_possible_edges()
        elif kind == "FAMILY":
            possible_packages = POSSIBLE_FAMILIES
            possible_edges = get_possible_family_edges()
            S = possible_packages + ["self_defined"]
        total_edges = stellar.number_of_edges()
        markov = []
        counts_nd_stuff = pd.Series(stellar.edges()).value_counts()


        for j in S:
            for k in S: ## we might have self calling loops
                edge = (j, k)
                try:
                    Pjk = counts_nd_stuff[edge]/total_edges
                    markov.append(Pjk)
                except ValueError:
                    markov.append(0)
        #outputfp = os.path.join(outFP, (app_name + "_" + kind + ".txt")) 
        
        # build output fp and save
        if (round(sum(markov)) == 1) & (not os.path.exists(outputfp)):
            try:
                np.savetxt(outputfp, markov, fmt = "%s")
                print("the app: ", inFP, " is done!", "mode: ", kind)
                return (inFP + " IS FINISHED!")
            except:
                print("the app: ", inFP, " encountered errors!")



    

if __name__ == "__main__":
    print("~ mamadroid ~")

    # file paths
    target = "/teams/DSC180A_FA20_A00/a04malware/personal-group03/markov_chain/package"

    # popular
    popular_apk_graphs_dir = "/teams/DSC180A_FA20_A00/a04malware/personal-group03/benign_graphs_sab/popular_apks/"
    popular_apk_graphs = [os.path.join(popular_apk_graphs_dir, fp) for fp in os.listdir(popular_apk_graphs_dir)]

    # random
    random_apk_graphs_dir = "/teams/DSC180A_FA20_A00/a04malware/personal-group03/benign_graphs_sab/random_apps/"
    random_apk_graphs = [os.path.join(random_apk_graphs_dir, fp) for fp in os.listdir(random_apk_graphs_dir)]
    
    # malware
    malware_dir = "/teams/DSC180A_FA20_A00/a04malware/apks/malware"
    malware_apks = [os.path.join(malware_dir, fp) for fp in os.listdir(malware_dir)]


    # check file size
    directory = [i for i in random_apk_graphs if os.path.getsize(i) != 72]
    print("length of filtered dir: ", len(directory))
    
    vfunc = np.vectorize(get_markov)
    
    # change directory and "FAMILY" to package as required
    results = vfunc(np.array(directory), target, "PACKAGE")
    print("popular package is finished!")
        


    

                
