import numpy as np
import regex as re
import networkx as nx
from stellargraph import StellarGraph
import concurrent.futures


import pandas as pd
import numpy as np

import os


# getting to utils
import sys,inspect
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0,parentdir)
import utils

POSSIBLE_FAMILIES = "Landroid,Lgoogle,Ljava,Ljavax,Lxml,Lapache,Ljunit,Ljson,Ldom".split(",")
POSSIBLE_PACKAGES = "/teams/DSC180A_FA20_A00/a04malware/personal-group03/mamadrioid_intermediate_files/all_possible_packages.txt"
POSSIBLE_EDGES = "/teams/DSC180A_FA20_A00/a04malware/personal-group03/mamadrioid_intermediate_files/all_possible_edges.txt"



def get_possible_packages():
    """
    obtains the list of possible packages for the latest API level, FOR PACKAGE MODE
    returns a list of possible packages. 
    """
    
    possible_packages = []
    with open(POSSIBLE_PACKAGES, 'r') as file:
        for line in file:
            line = "L" + line
            possible_packages.append(line.rsplit("."))
    file.close()
    return possible_packages
    

def get_possible_edges():
    """
    obtains the list of all possible edges according to the packages we have, for PACKAGE MODE
    """
    
    possible_edges = []
    with open(POSSIBLE_EDGES, 'r') as file:
        for line in file:
            sep = line.split()
            edge = (sep[0], sep[1])
            possible_edges.append(edge)
    file.close()
    return possible_edges

def get_possible_family_edges():
    """
    obtains the list of all possible edges created using FAMILY MODE
    """
    possible_edges = []
    for family1 in POSSIBLE_FAMILIES:
        for family2 in POSSIBLE_FAMILIES:
            possible_edges.append((family1, family2))
            
    return possible_edges

def get_package_family(kind, api):
    """
    gets a package or family from api
    
    kind --> string, FAMILY or PACKAGE
    api --> string of the api
    """
    package_fp = os.path.join(POSSIBLE_PACKAGES)
    possible_packages = []
    with open(package_fp, 'r') as file:
        for line in file:
            line = "L" + line
            possible_packages.append(line.split("."))
    file.close()

    if kind == "FAMILY":
        sep = api.split("/")[:1][0]
        if sep in POSSIBLE_FAMILIES:
            return sep
        else:
            return "self_defined"
       
    elif kind == "PACKAGE":
        
        for package in possible_packages:
            ct = 0
            for item in package:
                processed = item.replace("\n", "")
                if processed in api:
                    ct += 1
                else:
                    continue
            if (ct == len(package)) & (ct > 1):
                to_return = "/".join(package).replace("\n", "")
                return to_return
        if package == possible_packages[-1]:
            return "self_defined"


def edge_processing(edge, kind):
    """
    performs get_package_family on an edge
    edge --> a list that is an edge
    """
    new_edge = []
    for edg in edge:
        if type(edg) != int:
            new_edge.append(get_package_family(kind, edg))
        else:
            new_edge.append(edg)
    return new_edge


def get_markov(inFP, outFP, kind):
    
    """
    obtains the markov chain for one app
    
    inFP --> input file path (should be .gml.bz2)
    outFP --> output directory
    kind --> (str) FAMILY or PACKAGE
    
    """
    direc, app_name = utils.dir_and_app(inFP)
    
    networkx = nx.read_gml(inFP)
    nx_nodes = np.array(networkx.nodes())
    nx_edges = np.array(networkx.edges, dtype = object)
    
    # convert to package/family mode 
    vfunc = np.vectorize(get_package_family)
    newnodes = vfunc(kind, nx_nodes)
    new_edges = []
    for edge in nx_edges:
        new_edges.append(edge_processing(edge, kind))
    G = nx.MultiDiGraph()
    G.add_nodes_from(newnodes)
    G.add_edges_from(new_edges)
    stellar = StellarGraph.from_networkx(G)

    # step2: markov chain
    ## Set of possible states of the Markov chain is denoted as S
    ## If Sj and Sk are two connected states, Pjk denotes P(transition from Sj to Sk)
    ## Pjk is # occurances(Ojk), or edges(from j to k), divided by # of all occurrences
    ## Pjk = # of Edge(j, k) / # total edges
    if kind == "PACKAGE":
        possible_packages = get_possible_packages()
        S = ["/".join(item).strip() for item in possible_packages] + ["self_defined"]
        possible_edges = get_possible_edges()
    elif kind == "FAMILY":
        possible_packages = POSSIBLE_FAMILIES
        possible_edges = get_possible_family_edges()
        S = possible_packages + ["self_defined"]
    total_edges = stellar.number_of_edges()
    markov = []
    counts_nd_stuff = pd.Series(stellar.edges()).value_counts()


    for j in S:
        for k in S: ## we might have self calling loops
            edge = (j, k)
            try:
                Pjk = counts_nd_stuff[edge]/total_edges
                markov.append(Pjk)
            except ValueError:
                markov.append(0)
    outputfp = os.path.join(outFP, (app_name + "_" + kind + ".txt")) 
    
    # build output fp and save
    if (round(sum(markov)) == 1) & (not os.path.exists(outputfp)):
        np.savetxt(outputfp, markov, fmt = "%s")
        print("the app: ", inFP, " is done!")
        return (inFP + " IS FINISHED!")


    


def get_infos(user):
    """
    getting some useful filepaths and stuff
    """
    
    # get project directory 
    PROJECTDIR = os.path.dirname(parentdir)
    
    #### FILEPATHS ####
    # target 
    target = utils.get_to_directory(user, ["DSC180A_FA20_A00", "a04malware", "personal-group03", "mamadrioid_intermediate_files", "popular_apks"])

    # malwares (they're already graph format)
    malware_directory = utils.get_to_directory(user, ["DSC180A_FA20_A00", "a04malware", "apks", "malware"])

    # benigns
    benign1_directory = utils.get_to_directory(user, ["DSC180A_FA20_A00", "a04malware", "apks", "popular_apks"])
    benign2_directory = utils.get_to_directory(user, ["DSC180A_FA20_A00", "a04malware", "apks", "random-apps"])

    malware_apks = [os.path.join(malware_directory, fp) for fp in os.listdir(malware_directory)]
    benign1_apks = [os.path.join(benign1_directory, fp) for fp in os.listdir(benign1_directory)]
    benign2_apks = [os.path.join(benign2_directory, fp) for fp in os.listdir(benign2_directory)]

    return [target, malware_directory, benign1_directory, benign2_directory, malware_apks, benign1_apks, benign2_apks]
    

if __name__ == "__main__":
    print("~ mamadroid ~")

    #target, malware_directory, benign1_directory, benign2_directory, \
    #	malware_apks, benign1_apks, benign2_apks = get_infos("ssh026")

    # file paths
    target = "/teams/DSC180A_FA20_A00/a04malware/personal-group03/mamadrioid_intermediate_files/markov_chains"
    popular_apk_graphs_dir = "/teams/DSC180A_FA20_A00/a04malware/personal-group03/benign_graphs_sab/popular_apks/"
    
    popular_apk_graphs = [os.path.join(popular_apk_graphs_dir, fp) for fp in os.listdir(popular_apk_graphs_dir)]
    
    malware_dir = "/teams/DSC180A_FA20_A00/a04malware/apks/malware"
    malware_apks = [os.path.join(malware_dir, fp) for fp in os.listdir(malware_dir)]

#     # run on popular_apks
#     for apk in malware_apks[:1]:
#         get_markov(apk, "", 'PACKAGE')

  
#     with concurrent.futures.ThreadPoolExecutor() as executor:
#         future_to_apk = {executor.submit(get_markov, apk, target, "FAMILY"): apk for apk in malware_apks[2589:]}
#         for future in concurrent.futures.as_completed(future_to_apk):
#             apk = future_to_apk[future]
#             try:
#                 results = future.result()
#             except Exception as exc:
#                 print('%r generated an exception: %s' % (apk, exc))
#             else:
#                 print("app: ", apk, " is done")
                
                
    vfunc = np.vectorize(get_markov)
    results = vfunc(np.array(malware_apks[4126:]), target, "FAMILY")
    print("malware family is finished!")
                
                
#     with concurrent.futures.ThreadPoolExecutor() as executor:
#         future_to_apk = {executor.submit(get_markov, apk, target, "PACKAGE"): apk for apk in malware_apks}
#         for future in concurrent.futures.as_completed(future_to_apk):
#             apk = future_to_apk[future]
#             try:
#                 future.result()
#             except Exception as exc:
#                 print('%r generated an exception: %s' % (apk, exc))
#             else:
#                 print("app: ", apk, " is done")

#     with concurrent.futures.ThreadPoolExecutor() as executor:
#         future_to_apk = {executor.submit(get_markov, apk, target, "PACKAGE"): apk for apk in popular_apk_graphs}
#         for future in concurrent.futures.as_completed(future_to_apk):
#             apk = future_to_apk[future]
#             try:
#                 future.result()
#             except Exception as exc:
#                 print('%r generated an exception: %s' % (apk, exc))
#             else:
#                 print("app: ", apk, " is done")
                
                
#     with concurrent.futures.ThreadPoolExecutor() as executor:
#         future_to_apk = {executor.submit(get_markov, apk, target, "FAMILY"): apk for apk in popular_apk_graphs}
#         for future in concurrent.futures.as_completed(future_to_apk):
#             apk = future_to_apk[future]
#             try:
#                 future.result()
#             except Exception as exc:
#                 print('%r generated an exception: %s' % (apk, exc))
#             else:
#                 print("app: ", apk, " is done")

