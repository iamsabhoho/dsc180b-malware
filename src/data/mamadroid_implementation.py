import numpy as np
import regex as re
import networkx as nx
from stellargraph import StellarGraph

import pandas as pd
import numpy as np

import os


# getting to utils
import sys,inspect
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0,parentdir)
import utils

POSSIBLE_FAMILIES = "android, google, java, javax, xml, apache, junit, json, dom".split(",")
POSSIBLE_PACKAGES = "all_possible_packages.txt"
POSSIBLE_EDGES = "all_possible_edges.txt"


def get_possible_packages():
    """
    obtains the list of possible packages for the latest API level
    returns a list of possible packages. 
    """
    
    possible_packages = []
    with open(POSSIBLE_PACKAGES, 'r') as file:
        for line in file:
            line = "L" + line
            possible_packages.append(line.rsplit("."))
    file.close()
    return possible_packages
    

def get_possible_edges():
    """
    obtains the list of all possible edges according to the packages we have
    """
    
    possible_edges = []
    with open(POSSIBLE_EDGES, 'r') as file:
        for line in file:
            sep = line.split()
            edge = (sep[0], sep[1])
            possible_edges.append(edge)
    file.close()
    return possible_edges


def get_package_family(kind, api):
    """
    gets a package or family from api
    
    kind --> string, FAMILY or PACKAGE
    api --> string of the api
    """
    package_fp = os.path.join(POSSIBLE_PACKAGES)
    possible_packages = []
    with open(package_fp, 'r') as file:
        for line in file:
            line = "L" + line
            possible_packages.append(line.split("."))
    file.close()

    if kind == "FAMILY":
        sep = api.split("/")
        return "/".join(sep[:1])
    elif kind == "PACKAGE":
        
        for package in possible_packages:
            ct = 0
            for item in package:
                processed = item.replace("\n", "")
                if processed in api:
                    ct += 1
                else:
                    continue
            if (ct == len(package)) & (ct > 1):
                to_return = "/".join(package).replace("\n", "")
                return to_return
        if package == possible_packages[-1]:
            return "self_defined"


def edge_processing(edge):
    """
    performs get_package_family on an edge
    edge --> a list that is an edge
    """
    new_edge = []
    for edg in edge:
        if type(edg) != int:
            new_edge.append(get_package_family("PACKAGE", edg))
        else:
            new_edge.append(edg)
    return new_edge


def get_markov(inFP, outFP, kind):
    
    """
    obtains the markov chain for one app
    
    inFP --> input file path (should be .gml.bz2)
    outFP --> output directory
    kind --> FAMILY or PACKAGE
    
    """
    direc, app_name = utils.dir_and_app(inFP)
    
    networkx = nx.read_gml(inFP)
    nx_nodes = np.array(networkx.nodes())
    nx_edges = np.array(networkx.edges, dtype = object)
    
    # convert to package/family mode 
    vfunc = np.vectorize(get_package_family)
    newnodes = vfunc("PACKAGE", nx_nodes)
    new_edges = []
    for edge in nx_edges:
        new_edges.append(edge_processing(edge))
    G = nx.MultiDiGraph()
    G.add_nodes_from(newnodes)
    G.add_edges_from(new_edges)
    stellar = StellarGraph.from_networkx(G)

    # step2: markov chain
    ## Set of possible states of the Markov chain is denoted as S
    ## If Sj and Sk are two connected states, Pjk denotes P(transition from Sj to Sk)
    ## Pjk is # occurances(Ojk), or edges(from j to k), divided by # of all occurrences
    ## Pjk = # of Edge(j, k) / # total edges
    possible_packages = get_possible_packages()
    possible_edges = get_possible_edges()
    
    total_edges = stellar.number_of_edges()
    markov = []
    counts_nd_stuff = pd.Series(stellar.edges()).value_counts()
    S = ["/".join(item).strip() for item in possible_packages] + ["self_defined"]

    for j in S:
        for k in S: ## we might have self calling loops
            edge = (j, k)
            try:
                Pjk = counts_nd_stuff[edge]/total_edges
                possible_edges.append(edge)
                markov.append(Pjk)
            except ValueError:
                possible_edges.append(edge)
                markov.append(0)
                
    # build output fp and save
    
    outputfp = os.path.join(outFP, (app_name + "_" + kind + ".txt")) 
    np.savetxt(outputfp, markov, fmt = "%s")


def get_infos(user):
    """
    getting some useful filepaths and stuff
    """
    
    # get project directory 
    PROJECTDIR = os.path.dirname(parentdir)
    
    
    #### FILEPATHS ####
    # target 
    target = utils.get_to_directory(user, ["DSC180A_FA20_A00", "a04malware", "personal-group03", "mamadrioid_intermediate_files", "popular_apks"])


    # malwares (they're already graph format)
    malware_directory = utils.get_to_directory(user, ["DSC180A_FA20_A00", "a04malware", "apks", "malware"])

    # benigns
    benign1_directory = utils.get_to_directory(user, ["DSC180A_FA20_A00", "a04malware", "apks", "popular_apks"])
    benign2_directory = utils.get_to_directory(user, ["DSC180A_FA20_A00", "a04malware", "apks", "random-apps"])


    malware_apks = [os.path.join(malware_directory, fp) for fp in os.listdir(malware_directory)]
    benign1_apks = [os.path.join(benign1_directory, fp) for fp in os.listdir(benign1_directory)]
    benign2_apks = [os.path.join(benign2_directory, fp) for fp in os.listdir(benign2_directory)]
    
    return [target, malware_directory, benign1_directory, benign2_directory, malware_apks, benign1_apks, benign2_apks]
    

if __name__ == "__main__":
	print("~ mamadroid ~")

	target, malware_directory, benign1_directory, benign2_directory, \
		malware_apks, benign1_apks, benign2_apks = get_infos("ssh026")

	# run on popular_apks
	for apk in benign1_apks:
		get_markov(apk, target, POSSIBLE_PACKAGES)

	print("done")

