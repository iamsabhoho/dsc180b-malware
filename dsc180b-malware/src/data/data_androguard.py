from androguard import misc
from androguard import session
from stellargraph import StellarGraph
import networkx as nx



# txt file for apps
def train_txt(malware, benign1, benign2):
    """
    benign_fp --> file path for directory of benign_apps
    mali_fp --> file path for directory of malicious apps

    Assigns an ID to each app

    output --> train.txt containing train apps, columns = app_ID, app_fp, label
    """

    benign_apps = [(benign1 + bee) for bee in os.listdir(benign1)] + \
    [(benign2 + bee) for bee in os.listdir(benign2)]
    benign_labels = [0] * len(benign_apps)
    print(len(benign_apps))

    # note, malware are already CFGs
    malware_apps = [(malware + bee) for bee in os.listdir(malware)]
    malware_labels = [1] * len(malware_apps)
    print(len(malware_apps))

    apps = benign_apps + malware_apps
    labels = benign_labels + malware_labels

    # app ID's
    app_id = range(0, (len(benign_apps) + len(malware_apps)))

    csv = pd.DataFrame({
        "app_fp":apps,
        "app_label":labels,
        "app_ID":app_id
    })

    csv.to_csv("features/app_label_id.txt", index=  False)
    return csv


def get_graphs(directory, target):
    """
    gets graphs from APKSs

    directory --> a directory containing the apps we want to get graphs from
    output --> outputs  .gml.bz2 files to a target destination
    """


    settings = {
    # The directory `some/directory` should contain some APK files
    "my": AndroTest('some/directory'),
    # Use the default Logger
    "log": auto.DefaultAndroLog,
    # Use maximum of 2 threads
    "max_fetcher": 2,
    }

    aa = auto.AndroAuto(settings)
    aa.go()





def decompile_apk(filepath, session_n = ""):
    '''
    decompiles an apk and returns a, d, dx

    filepath --> path to the APK file
    session_n --> session filename, extension is '.ag'

    function returns a list with items: [a, d, dx]
    a: APK object
    d: array of DalvikVMFormat
    dx: Analysis object
    '''

    # stores a session, we can return to work on this later
    if session != "":
        sess = misc.get_default_session()
        a, d, dx = misc.AnalyzeAPK(filepath, session = sess)
        session.Save(sess, "sessions/"+session_n)
        return [a, d, dx]
    else:
        a, d, dx = misc.AnalyzeAPK(filepath)
        return [a, d, dx]

def features_encoder(node_data):
    """
    encoding the feature dictionary from .get_call_graph() from Androguard
    """
    keywords= ["external", 'entrypoint', 'native', 'public', 'static'] #'vm', 'codesize']
    vector = []
    for keyword in keywords:
        try:
            if node_data[keyword] == True:
                vector.append(1)
            else:
                vector.append(0)
        except:
            vector.append(0)

    return vector

def features_encoder2(node_data):
    '''
    gets the node type for an individual node

    returns a string
    '''
    keywords = ["external", 'entrypoint', 'native', 'public', 'static']

    string = ""
    for keyword in keywords:
        if node_data[keyword] == True:
            string += (keyword + ",")

    string = string[:-1]
    string += "Node"
    return string

def call_graph(dx):
    """
    1. gets the call graph (CFG) from the analysis object (dx)
    2. processes the nodes by giving them a node_type for easier representation
    3. also gives edges representation

    returns a stellargraph.core.graph.StellarDiGraph object


    dx --> analysis object from decompiling an apk
    """

    call_graph_nx = dx.get_call_graph()
    for node_id, node_data in call_graph_nx.nodes(data = True):
        node_data['feature'] = features_encoder(node_data)
        node_data['type'] = features_encoder2(node_data)


    call_graph_sg = graph = StellarGraph.from_networkx(test_dx, node_features = \
    "feature", node_type_attr = 'type', edge_type_attr = 'offset')

    return call_graph_sg

class AndroTest(auto.DirectoryAndroAnalysis):
    def __init__(self, path):
        super(AndroTest, self).__init__(path)
            self.has_crashed = False

    def analysis_app(self, log, apkobj, dexobj, analysisobj):
        # Just print all objects to stdout
        print(log.id_file, log.filename, apkobj, dexobj, analysisobj)

    def finish(self, log):
        # This method can be used to save information in `log`
        # finish is called regardless of a crash, so maybe store the
        # information somewhere
        if self.has_crashed:
            print("Analysis of {} has finished with Errors".format(log))
        else:
            print("Analysis of {} has finished!".format(log))

    def crash(self, log, why):
        # If some error happens during the analysis, this method will be
        # called
        self.has_crashed = True
            print("Error during analysis of {}: {}".format(log, why), file=sys.stderr)



if __name__ == "__main__":

    #
    # # testing on LOCAL DESKTOP COMPUTER ONLY
    # fp = "C:/Users/USER/Documents/GitHub/dsc180b-localtesting/data"
    # print("filepath is: ", fp)
    # a, d, dx = decompile_apk(fp)
    # print(call_graph(dx).info())
