from androguard import misc
from androguard import session
from stellargraph import StellarGraph
import networkx as nx
from androguard.core.analysis import auto
from datetime import datetime
import sys
import os


# concurrency
import concurrent.futures

## getting utils
import sys,inspect
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0,parentdir)
import utils




# txt file for apps
def train_txt(malware, benign1, benign2):
    """
    benign_fp --> file path for directory of benign_apps
    mali_fp --> file path for directory of malicious apps

    Assigns an ID to each app

    output --> train.txt containing train apps, columns = app_ID, app_fp, label
    """

    benign_apps = [(benign1 + bee) for bee in os.listdir(benign1)] + \
    [(benign2 + bee) for bee in os.listdir(benign2)]
    benign_labels = [0] * len(benign_apps)
    print(len(benign_apps))

    # note, malware are already CFGs
    malware_apps = [(malware + bee) for bee in os.listdir(malware)]
    malware_labels = [1] * len(malware_apps)
    print(len(malware_apps))

    apps = benign_apps + malware_apps
    labels = benign_labels + malware_labels

    # app ID's
    app_id = range(0, (len(benign_apps) + len(malware_apps)))

    csv = pd.DataFrame({
        "app_fp":apps,
        "app_label":labels,
        "app_ID":app_id
    })

    csv.to_csv("features/app_label_id.txt", index=  False)
    return csv


##################### ETL (EXTRACTING, TRANSFORMING, LOADING DATA) ######



#     futures = []
#     with ThreadPoolExecutor(8) as executor:

#         for directory in directories:
#             filepaths = os.listdir(directory)
#             for filepath in filepaths:
#                 real_p = os.path.join(directory, filepath)
#                 now = datetime.now()
#                 futures.append(executor.submit(decompile_apk, real_p, target))
#         for job in as_completed(futures):
#             results = job.result()


def etl(directories, target):
    """
    perform ETL on directories, outputs to targets

    ETL process:
    1. apk --> decompile to a, d, dx
    2. a, d, dx --> dx.get_call_graph() (networkx object)
    3. perform feature extraction on (networkx object)
    4. export networkx object as a compressed .gml file

    directory --> directories containing the apps we want to get graphs from
    target --> outputs folder .gml.bz2 files to a target destination
    """

#     for directory in directories:
#         filepaths = os.listdir(directory)
#         for filepath in filepaths:
#             real_p = os.path.join(directory, filepath)
#             decompile_apk(real_p, target)
    futures = []

    with concurrent.futures.ThreadPoolExecutor(6) as executor:
        for directory in directories:
            filepaths = os.listdir(directory)
            for filepath in filepaths:
                real_p = os.path.join(directory, filepath)
                futures.append(executor.submit(decompile_apk, real_p, target))

        for future in concurrent.futures.as_completed(futures):
            print(future.result())









def decompile_apk(filepath, target_dir):
    '''
    decompiles an apk and outputs a gml file of the graph. Will write to disk.

    filepath --> path to the APK file
    session_n --> session filename, extension is '.ag'


    '''
    # build fp
    path, app = os.path.split(filepath)
    app = app.replace(".apk", "")

    final_path = os.path.join(target_dir, (app + ".gml.bz2"))


    a, d, dx = misc.AnalyzeAPK(filepath)
    networkx_graph = dx.get_call_graph()

    mapping = {}
    for node_id, node_data in networkx_graph.nodes(data = True):
        mapping[node_id] = str(node_id.get_method().full_name)
        node_data['feature'] = features_encoder(node_data)
        node_data['type'] = features_encoder2(node_data)

    G = nx.relabel_nodes(networkx_graph, mapping)
    nx.write_gml(G, final_path)

    return "Done"

def features_encoder(node_data):
    """
    encoding the feature dictionary from .get_call_graph() from Androguard
    """
    keywords= ["external", 'entrypoint', 'native', 'public', 'static'] #'vm', 'codesize']
    vector = []
    for keyword in keywords:
        try:
            if node_data[keyword] == True:
                vector.append(1)
            else:
                vector.append(0)
        except:
            vector.append(0)

    return vector

def features_encoder2(node_data):
    '''
    gets the node type for an individual node

    returns a string
    '''
    keywords = ["external", 'entrypoint', 'native', 'public', 'static']

    string = ""
    for keyword in keywords:
        if node_data[keyword] == True:
            string += (keyword + ",")

    string = string[:-1]
    string += "Node"
    return string

def call_graph(dx):
    """
    1. gets the call graph (CFG) from the analysis object (dx)
    2. processes the nodes by giving them a node_type for easier representation
    3. also gives edges representation

    returns a stellargraph.core.graph.StellarDiGraph object


    dx --> analysis object from decompiling an apk
    """

    call_graph_nx = dx.get_call_graph()
    for node_id, node_data in call_graph_nx.nodes(data = True):
        node_data['feature'] = features_encoder(node_data)
        node_data['type'] = features_encoder2(node_data)


    call_graph_sg = graph = StellarGraph.from_networkx(test_dx, node_features = \
    "feature", node_type_attr = 'type', edge_type_attr = 'offset')

    return call_graph_sg


class AndroTest(auto.DirectoryAndroAnalysis):
    def __init__(self, path):
        super(AndroTest, self).__init__(path)
        self.has_crashed = False

    def analysis_app(self, log, apkobj, dexobj, analysisobj):
        # Just print all objects to stdout
        networkx_graph = analysisobj.get_call_graph()

        mapping = {}
        for node_id, node_data in networkx_graph.nodes(data = True):
            mapping[node_id] = str(node_id.get_method().full_name)
            node_data['feature'] = features_encoder(node_data)
            node_data['type'] = features_encoder2(node_data)

        G = nx.relabel_nodes(networkx_graph, mapping)
        TARGET_DIR = utils.get_to_directory('edwinhuang', ["Documents", "GitHub", "dsc180b-localtesting", "data", "output"])
        app = str(len(os.listdir(TARGET_DIR)) + 1)
        final_path = os.path.join(TARGET_DIR, (app + ".gml.bz2"))
        nx.write_gml(G, final_path)


    def finish(self, log):
       # This method can be used to save information in `log`
       # finish is called regardless of a crash, so maybe store the
       # information somewhere
       if self.has_crashed:
           print("Analysis of {} has finished with Errors".format(log))
       else:
        print("Analysis of {} has finished!".format(log))

    def crash(self, log, why):
        # If some error happens during the analysis, this method will be
        # called
        self.has_crashed = True
        print("Error during analysis of {}: {}".format(log, why), file=sys.stderr)


if __name__ == "__main__":

    # ur username: change here
    USER = "edh021"


    # target
    target = utils.get_to_directory(USER, ["DSC180A_FA20_A00", "a04malware", "personal-group03", "benign_graphs"])
    # malwares (they're already graph format)
    malware_directory = utils.get_to_directory(USER, ["DSC180A_FA20_A00", "a04malware", "apks", "malware"])
    # benigns
    benign1_directory = utils.get_to_directory(USER, ["DSC180A_FA20_A00", "a04malware", "apks", "popular_apks"])
    benign2_directory = utils.get_to_directory(USER, ["DSC180A_FA20_A00", "a04malware", "apks", "random-apps"])

    print("does file paths exist? Target:", os.path.exists(target), " malware: ", os.path.exists(malware_directory), " benign1: ", os.path.exists(benign1_directory), " benign2: ", os.path.exists(benign2_directory))


    now = datetime.now()

    settings = {
        "my" : AndroTest("/Users/edwinhuang/Documents/GitHub/dsc180b-localtesting/data/apks"),
        "log":auto.DefaultAndroLog,
        "max_fetcher":4
    }

    aa = auto.AndroAuto(settings)
    aa.go()

    print("5 same apps took: ", (datetime.now() - now))
